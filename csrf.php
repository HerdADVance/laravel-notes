
Cross-Site Request Forgeries are a malicious exploit where unauthorized commands are performed on behalf of an authenticated user.

Without protection against CSRF, a malicious website would create an HTML form that points to your application's user/email route and trick a user from your site to the page with that form. Then their email address would be changed in your app.

To prevent this, we need to inspect every incoming POST, PUT, PATCH, or DELETE request for a secret session value that a malicious app wouldn't be able to access.

CSRF middleware is automatically disabled for all routes when running tests.


Preventing CSRF Requests
=======================

Laravel automatically generates a CSRF token for each active user session managed by your application. It verifies that the authenticated user is actually the person making the requests.

The current session's token can be accessed via the request's session or with the csrf_token helper function:

<?
	Route::get('/token', function (Request $request) {
	    
	    // accessing the token with the request session
	    $token = $request->session()->token();

	    // or accessing it with the helper function
	    $token = csrf_token();

	    // do other stuff with the token

	});
?>


CSRF in Forms
==============

Any form should have a CSRF _token field so the CSRF protection middleware can validate the request:

<form method="POST" action="/profile">
    @csrf

    <!-- Equivalent to... -->
    <input type="hidden" name="_token" value="{{ csrf_token() }}" />
</form>

The App\Http\Middleware\VerifyCsrfToken middleware is what is responsible for this validation.


Excluding URI's from CSRF Protection
====================================

Sometimes you need to exclude a URI from CSRF protection.

For example, if your app uses Stripe to process payments, you'll need to include their webhook handler route from CSRF protection since Stripe won't know about the token.

Typically, these kind of routes should be placed outside of the "web" middleware group that the RouteServiceProvider applies to all routes in the web.php file.

However, you can also exclude them by adding their URI's to the $except property of the VerifyCsrfToken middleware:

<?
	namespace App\Http\Middleware;

	use Illuminate\Foundation\Http\Middleware\VerifyCsrfToken as Middleware;

	class VerifyCsrfToken extends Middleware
	{
	    protected $except = [
	        'stripe/*',
	        'http://example.com/foo/bar',
	        'http://example.com/foo/*',
	    ];
	}
?>


X-CSRF Token
==================

The VerifyCsrfToken middleware will also check for the X-CSRF-TOKEN request header. This could be stored in an HTML meta tag:

<meta name="csrf-token" content="{{ csrf_token() }}">

Then, a library like jQuery could automatically add the token to all request headers. This provides content CSRF protection for AJAX based applications:

<script>
	$.ajaxSetup({
	    headers: {
	        'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
	    }
	});
</script>


X-XSRF Token
==============

Laravel stores the current CSRF token in an encrypted XSRF-TOKEN cookie that is included with each response generated by the framework. This cookie can be used to set the X-XSRF-TOKEN request header.

This cookie is sent to be a developer convenience since some JS frameworks/libraries automatically place its value in the X-XSRF-TOKEN header on same-origin requests.

By default, the resources/js/bootstrap.js file includes the Axios HTTP library which will automatically send the X-XSRF-TOKEN header for you.



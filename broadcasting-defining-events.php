
To inform Laravel that a given event should be broadcast, you must implement the Illuminate\Contracts\Broadcasting\ShouldBroadcast interface on the event class. 

This interface is already imported into all event classes generated by the framework you can easily add it to any of your events.

The ShouldBroadcast interface requires you to implement a single method called broadcastOn.

This method returns a channel or array of channels that the event should be broadcast on.

The channels should be instances of Channel, PrivateChannel, or PresenceChannel. The former of those represents public channels while the other two represent private channels that require channel authorization.

<?
	namespace App\Events;

	use App\Models\User;
	use Illuminate\Broadcasting\Channel;
	use Illuminate\Broadcasting\InteractsWithSockets;
	use Illuminate\Broadcasting\PresenceChannel;
	use Illuminate\Broadcasting\PrivateChannel;
	use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
	use Illuminate\Queue\SerializesModels;

	class ServerCreated implements ShouldBroadcast
	{
	    use SerializesModels;

	    public $user;

	    public function __construct(User $user)
	    {
	        $this->user = $user;
	    }

	    public function broadcastOn()
	    {
	        return new PrivateChannel('user.'.$this->user->id);
	    }
	}
?>

After implementing that ShouldBroadcast interface, you only need to fire the event as you normally would.

After the event has been fired, a queued job will automatically broadcast the event on your specified broadcast driver.


Broadcast Name
================

By default, Laravel will broadcast the event using the event's class name, but you can customize the broadcast name by defining a broadcastAs method on the event:

<?
	public function broadcastAs()
	{
	    return 'server.created';
	}
?>

If you customize the broadcast name this way, make sure to register your listener with a leading dot. This will instruct Echo to not prepend the application's namespace to the event:

<script>
	.listen('.server.created', function (e) {
	    ....
	});
</script>


Broadcast Data
==================

When an event is broadcast, all of its public properties are automatically serialized and broadcast as the event's payload. This allows you to access any of its public data from your JS app.

For example, if your event has a single public $user property that contains an Eloquent model, the event's broadcast payload would be:

<scriot>
	{
	    "user": {
	        "id": 1,
	        "name": "Patrick Stewart"
	        ...
	    }
	}
</script>

If you want more fine-grained control over the payload, add a broadcastWith method to the event.

This method will return the array of data you wish to broadcast as the event payload:

<?
	public function broadcastWith()
	{
	    return ['id' => $this->user->id];
	}
?>


Broadcast Queue
=================

By default, each broadcast event is placed on the default queue for the default queue connection specified in your queue.php config file.

You can customize the queue connection and name used by the broadcaster by defining connection and queue properties on your event class:

<?
	public $connection = 'redis';

	public $queue = 'default';

?>

If you want to broadcast your event using the sync queue instead of the default queue driver, implement the ShouldBroadcastNow interface instead of ShouldBroadcast:

<?
	use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

	class OrderShipmentStatusUpdated implements ShouldBroadcastNow
	{
	    //
	}
?>


Broadcast Conditions
======================

Sometimes you want to broadcast your event only if a given condition is true. Use the broadcastWhen method in your event class for this:

<?
	public function broadcastWhen()
	{
    	return $this->order->value > 100;
	}
?>


Broadcasting & DB Transactions
============================

When broadcast events are dispatched within DB transactions, they can be processed by the queue before the DB transaction has committed.

When this happens, any updates you've made to models or DB records during the transaction may not yet be reflected in the DB.

In addition, any models or DB records created within the transaction may not exist in the DB.

If your event depends on these models, unexpected errors can occur when the job that broadcasts the event is processed.

If your queue connection's after_commit config option is set to false, you may still indicate that a particular broadcast event should be dispatched after all open DB transactions have been committed by defining an $afterCommit property on the event class:

<?
	namespace App\Events;

	use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
	use Illuminate\Queue\SerializesModels;

	class ServerCreated implements ShouldBroadcast
	{
	    use SerializesModels;

	    public $afterCommit = true;
	}
?>

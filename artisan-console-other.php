
Registering Commands
====================

All of your console commands are registered withing your app's console kernel.

Within the commands method of this class, you'll see a call to the kernel's load method. This method will scan the app/Console/Commands directory and automatically register each command it contains with Artisan.

You can make additional calls to the load method to scan other directories for Artisan commands.

<?
	protected function commands()
	{
	    $this->load(__DIR__.'/Commands');
	    $this->load(__DIR__.'/../Domain/Orders/Commands');

	    // ...
	}
?>

If necessary you can manually register commands by adding the command's class name to the $commands property. When Artisan boots, all commands listed in this property will be resolved by the service container and registered with Artisan.

<?
	// SendEmails is a hypothetical command we created earlier
	protected $commands = [
	    Commands\SendEmails::class
	];
?>


Programatically Executing Commands
==================================

Sometimes you may wish to execute an Artisan command outside of the CLI. Maybe in a route or controller.

To do this, use the call method on the Artisan facade. 

This method accepts either the command's signature name or class name as the 1st argument and an array of command parameters as the 2nd argument.

<?
	use Illuminate\Support\Facades\Artisan;

	Route::post('/user/{user}/mail', function ($user) {
	    $exitCode = Artisan::call('mail:send', [
	        'user' => $user, '--queue' => 'default'
	    ]);

	    //
	});

	// syntax for passing array values
	Route::post('/mail', function () {
	    $exitCode = Artisan::call('mail:send', [
	        '--id' => [5, 13]
	    ]);
	});
?>

Alternatively, you can pass the entire Artisan command to the call method as a string:

	<? Artisan::call('mail:send 1 --queue=default'); ?>


Queueing Artisan Commands
=========================

With the queue method on the Artisan facade, you can queue Artisan commands so they're processed in the background by your queue workers.

Make sure you have configured your queue and are running a queue listener.

<?
	use Illuminate\Support\Facades\Artisan;

	Route::post('/user/{user}/mail', function ($user) {
	    Artisan::queue('mail:send', [
	        'user' => $user, '--queue' => 'default'
	    ]);

	    //
	});
?>

The onConnection and onQueue methods let you specify the connection and queue the Artisan command should be dispatched to:

<?
	Artisan::queue('mail:send', [
	    'user' => 1, '--queue' => 'default'
	])->onConnection('redis')->onQueue('commands');
?>


Calling Commands from Other Commands
====================================

If you want to call other commands from an existing Artisan command, use the call method:

<?
	public function handle()
	{
	    $this->call('mail:send', [
	        'user' => 1, '--queue' => 'default'
	    ]);

	    //
	}
?>

You can call another console command and suppress all of its output with the callSilently method:

<?
	$this->callSilently('mail:send', [
	    'user' => 1, '--queue' => 'default'
	]);
?>



Stub Customization
===================

The Artisan console's make commands are used to create a variety of classes such as controlers, jobs, migrations, and tests.

These classes are generated using "stub" files that are populated with values based on your input.

However, you may want to make small changes to files generated by Artisan. To do this, use the stub:publish command to publish the most common stubs to your app so you can customize them:

	<? php artisan stub:publish ?>

The published stubs will be located in a stubs directory in the root of your app.

Any changes you make to these stubs will be reflected when you generate their corresponding classes using Artisan's make command.


Events
===============

Artisan dispatches three events when running commands:

	Illuminate\Console\Events\ArtisanStarting
	Illuminate\Console\Events\CommandStarting
	Illuminate\Console\Events\CommandFinished

